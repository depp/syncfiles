package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"moria.us/macscript/charmap"
	"moria.us/macscript/table"
)

const header = "/* This file is automatically generated. */\n"

func getSrcdir() (string, error) {
	exe, err := os.Executable()
	if err != nil {
		return "", err
	}
	return filepath.Dir(filepath.Dir(exe)), nil
}

func mainE() error {
	srcdir, err := getSrcdir()
	if err != nil {
		return fmt.Errorf("could not find source dir: %v", err)
	}
	if err := os.Chdir(srcdir); err != nil {
		return err
	}

	// Read metadata.
	d, err := readData()
	if err != nil {
		return err
	}

	// Compile and emit charmap data.
	cms := make([]string, len(d.charmaps))
	var hascmap bool
	for i, c := range d.charmaps {
		if c.file == "" {
			continue
		}
		cm, err := charmap.ReadFile(filepath.Join("charmap", c.file))
		if err != nil {
			return err
		}
		t, err := table.Create(cm)
		if err != nil {
			if e, ok := err.(*table.UnsupportedError); ok {
				fmt.Fprintf(os.Stderr, "Warning: unsupported charmap %q: %s\n", c.file, e.Message)
				continue
			}
			fmt.Fprintf(os.Stderr, "Error: %s: %v", c.file, err)
			os.Exit(1)
		}
		data := t.Data()
		name := "charmap_" + strings.ToLower(strings.TrimSuffix(c.file, ".TXT")) + ".dat"
		fpath := filepath.Join("src", name)
		fmt.Fprintln(os.Stderr, "Writing:", fpath)
		if err := ioutil.WriteFile(fpath, data, 0666); err != nil {
			return err
		}
		cms[i] = name
		hascmap = true
	}
	if !hascmap {
		return errors.New("could not compile any character map")
	}

	// Write generated output.
	m := genMap(&d)
	if err := writeMap(&d, m, "src/getcharmap.c"); err != nil {
		return err
	}
	if err := writeRez(&d, cms, "src/charmaps.r"); err != nil {
		return err
	}
	return nil
}

func main() {
	flag.Parse()
	if args := flag.Args(); len(args) != 0 {
		fmt.Fprintf(os.Stderr, "Error: unexpected argument: %q\n", args[0])
		os.Exit(2)
	}
	if err := mainE(); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}
